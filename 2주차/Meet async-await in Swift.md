# async/await 이란?

- 비동기 프로그래밍을 좀 더 안전하고 간편하게 해주기 위해 도입된 API

# 비동기 프로그래밍이 뭘까

- 일반적으로 우리가 작성하는 코드들은 대부분 메인 스레드에서 동기적으로 동작하는 코드들이다. 즉 코드들이 모두 순서대로 동작한다. 그런데, 종종 우리는 메인 스레드에서만 처리하기에는 다소 무거울 수 있는 작업들도 수행해야할 때(대표적으로 네트워크 통신)가 있다. 예를 들어 네트워크 통신 작업을 수행한다고 했을 때, 우리는 request를 보내고 response가 올 때까지, 메인 스레드가 작업을 마칠 때까지 마냥 기다리는 수밖에 없다. 즉 쓸데 없는 시간낭비와 비효율이 발생하게 된다. 이럴 때 우리는 ‘**비동기 프로그래밍**’이 필요하게 된다. 우리는 열심히 일하는 메인 스레드말고 여러 개의 놀고 먹고 있는 백그라운드 스레드가 있다! 무거운 작업을 수행해야될 경우, 우리는 해당 작업을 백그라운드 스레드로 보내버리고 메인 스레드는 다른 가벼운 작업들을 이어서 계속 수행할 수 있다. 이후 메인스레드는 백그라운드 스레드에서 무거운 작업이 끝나면 그 작업에 대한 업데이트를 처리해주기만 하면 된다. 이렇게 비동기적으로 코드를 작성하는 것을 ‘**비동기 프로그래밍**’이라고 한다.

# 기존 방식의 비동기 프로그래밍

- 기존에 우리가 즐겨 사용하던 방식은 네트워크 통신의 경우, Swift에서 제공하고 있는 URLSession의 dataTask 메서드를 활용하여 백그라운드 스레드에서 작업을 처리한 후, 작업의 결과를 escaping closure인 completionHandler로 넘겨줘서 해당 네트워크 통신의 response를 처리해줬다. 그런데 이러한 방식은 여러 개의 네트워크 작업이 중첩되어 수행해야할 때 문제가 발생한다. 만약 어떤 네트워크 작업이 끝난 뒤 통신이 성공했을 때 수행해야할 또 다른 네트워크 작업이 있다면? 또 성공한 뒤에 다른 작업을 또 해야한다면? 우리는 코드로 열심히 등산을 하고 있을 것이다. 코드가 등산만 하는 것뿐만아니라 개발자가 중간중간에 실패케이스를 대응하기가 매우매우 힘들어진다. 가독성이 좋지 않아지기 때문에 휴먼 에러 또한 발생가능성이 높아진다.

- 예시를 통해 보자.

![스크린샷 2022-11-22 오전 12 11 54](https://user-images.githubusercontent.com/87598209/203332223-1a02a5e1-0f8c-43b8-a9dd-67a30cd7804c.png)

- 위의 예시의 경우, 어떤 이미지의 썸네일을 서버로부터 가져오는 일련의 과정이다. request를 하고 response가 오면 데이터를 UIImage로 넘겨주고 prepareThumbnail메서드를 실행시켜준 뒤 UI를 업데이트해준다. 이 모든건 작업 순서가 보장되어야한다. 그런데 작업 시간이 어느정도 필요한 메서드가 2개가 존재한다(dataTask, prepareThumbnail)

![스크린샷 2022-11-22 오전 12 15 02](https://user-images.githubusercontent.com/87598209/203332284-7a635e20-b6b8-4c60-bfde-1a7256082194.png)

- 기존방식대로 비동기 프로그래밍을 한다면, 우리는 위와 같은 코드를 작성하게 된다.
- 이렇게 작성하게될 경우, 문제점이 몇 가지 발생한다.
    - completion을 누락하는 경우가 존재한다. 현재 guard let문의 else문을 보면 따로 completion을 넘겨주지 않고 있다. 이렇게 될 경우, 통신 결과는 성공했지만 이미지나 썸네일이 존재하지 않을 경우 우리는 절대 결과를 받아보지 못한다. 그 외의 케이스에서도 개발자가 실수로 completion을 넘겨주는 걸 놓치는 경우가 발생할 수 있다.
    - self를 캡처하게 되면서 순환참조로 인한 메모리릭 이슈 유발 가능성 존재
    - 뎁스가 깊어지면서 가독성이 안좋아진다(코드가 못생겨짐)
- 이러한 문제점들을 효과적으로 해결하기 위해 **async/await**가 등장하게 된다.

# async/await

![스크린샷 2022-11-22 오전 12 35 00](https://user-images.githubusercontent.com/87598209/203332365-cb1ba4e1-5f88-46ed-bd0f-9567da1d59cb.png)

- 우선 결과물부터 보고 시작해보자. 위의 코드는 20줄이 넘어가던 코드를 async/await을 활용하여 단 6줄로 줄여놓은 코드이다. 심지어 더 안전하고 가독성이 좋다. 마구잡이로 남발하고 있는 completion도 없다!
- 이제 세부적으로 살펴보면, 먼저 함수명에 붙어있는 async의 경우 이 함수가 비동기로 처리되는 함수라는 것을 표현해주는 키워드이다.
- 그 뒤에 붙은 throws의 경우 이 함수가 여러 에러들을 throw할 수 있다는 것을 의미한다.
- data를 request하는 메서드 앞에 붙은 await키워드의 경우, 해당 비동기 메서드의 작업을 끝날 때까지 기다린다는 뜻이다.
- 바로 앞에 붙은 try는 data메서드가 에러를 throw할 수 있으니 붙여주는 키워드이다. 만약 에러를 throw하지 않는 비동기 메서드일 경우, 붙여주지 않는다.
- 이렇게 코드를 작성해줌으로써, 우리는 분명 비동기 프로그래밍을 했지만 마치 동기적으로 동작하는 것처럼 보이는 효과를 얻을 수 있다. 훨씬 가독성도 좋음.

# async properties

- async 키워드는 연산 프로퍼티에서도 사용할 수 있다!
- 단, 주의해야할 점은 setter가 없는 get-only(read-only) 프로퍼티에서만 사용할 수 있다
    
![스크린샷 2022-11-22 오후 8 43 56](https://user-images.githubusercontent.com/87598209/203332415-3a1df867-a514-423e-8098-a025d4bc3049.png)

- 위 예시도 마찬가지로 만약 에러를 던져줘야 한다면 get async 옆에다가 throws만 적어주면 된다

# Thread Control

- async 키워드가 붙은 비동기 함수는 암시적으로 함수내의 task가 suspend 될 수도 있음(may suspend)을 내포하고 있음. 이렇게 일시정지 되는 시점을 표현해주는게 **await** 키워드이다.
- suspend된 비동기 함수는 제어하고 있던 스레드 제어 권한을 잠시 시스템에게 줄 수 있다. 시스템은 스레드 제어 권한을 받아서 우선순위가 높은 다른 작업(섬네일 가져오고 있는데 유저가 다른 버튼을 탭한다던지 등등)을 처리하다가 다시 함수에게 넘겨주게 된다.
- 제어 권한을 넘겨받은 함수는 suspend된 task를 이어서 수행(resume)하게 된다
- 이때, 함수의 스레드가 제어 권한을 넘겨줄 때의 스레드와 돌려 받을 때의 스레드가 달라질 수 있다(시스템이 알아서 판단해서 작업하기 적당한 스레드로 돌려줌)
    
![스크린샷 2022-11-22 오후 9 16 31](https://user-images.githubusercontent.com/87598209/203332445-2d107593-f88e-4bae-8bcc-f89ec1358ca5.png)

# Async/await facts

- async는 함수가 suspend 될 수 있게 만들어주는 키워드이다
- await 키워드가 붙어있는 비동기 함수는 실행이 suspend될 수도 있음을 의미한다.(반드시 suspend되는건 아님)
- 다른 작업들은 비동기 함수가 중단되어 있는 동안에 수행되어질 수 있다
- 다른 작업들이 끝나면 중단된 비동기 함수는 작업을 이어서 수행할 수 있다

# Testing async code

- 테스트 코드에서도 우리는 async/await 키워드를 활용하여 테스트 코드를 훨씬 깔끔하게 작성할 수 있음

![스크린샷 2022-11-22 오후 9 28 55](https://user-images.githubusercontent.com/87598209/203332473-7a2770f5-2d3f-4f4d-8188-68cabc17bd51.png)

- 일반적으로 async키워드를 쓰지 않는다면 우리는 fetchThumbnail 함수가 끝날때까지 기다렸다가 결과값을 받은 다음에 expectation을 채워줘야하므로 wait 메서드를 사용하여 일정 시간을 어쩔 수 없이 기다려야만 했다

![스크린샷 2022-11-22 오후 9 29 15](https://user-images.githubusercontent.com/87598209/203332495-c5438102-1c13-4e10-ba39-243876e2f121.png)
    
- 그러나 async/await 키워드를 사용하면 위와 같이 훨씬 간결하게 테스트 코드를 작성해줄 수 있다

# Task

- async/await 키워드를 아무 상황에서나 다 쓸 수 있는 것은 아니다. 아래 화면과 같은 상황을 마주칠 수 있다

![스크린샷 2022-11-22 오후 9 43 23](https://user-images.githubusercontent.com/87598209/203332508-40b930c6-9642-4eb9-8dc1-9e995df1a89f.png)

- 비동기 함수인 fetchThumbnail을 처리해주기 위해 await 키워드를 붙였지만 에러가 난 것을 확인할 수 있다
- 이유는 onAppear 클로저가 비동기 함수가 아니기 때문이다. 즉 async 비동기 함수는 같은 비동기 함수내에서만 호출이 가능하다.
- 그렇다면 async를 쓰는게 사실 큰 메리트가 없을 수 있는데, 이럴때 우리는 **Task**를 활용하여 비동기 함수가 아닌 함수 context 내에서 비동기로 처리되는 클로저를 만들어 줄 수 있다.
    
![스크린샷 2022-11-22 오후 9 51 17](https://user-images.githubusercontent.com/87598209/203332950-48dbe36d-c1d1-4819-be42-3199e22e428c.png)

# Async alternatives and continuations

- 우리는 async/await이 도입되어지기 이전에는 비동기 코드를 처리해주기 위해 completionHandler를 주로 활용해주고 있었다. 그렇다보니 우리의 레거시 비동기 코드들에 단순히 async 키워드를 모든 곳에 붙여서 사용하는 곳은 우리의 앱의 안정성에 아주 큰 영향을 미칠 수 있다
- 이럴때, 우리는 **continuation** 이라는 대안을 사용해줄 수 있다

![스크린샷 2022-11-22 오후 10 43 17](https://user-images.githubusercontent.com/87598209/203333038-5663cc28-e7bd-4ad5-82c2-ff1f13364ebd.png)

- 위의 메서드를 앱의 여러 곳에서 사용하고 있고 잘 동작하던 코드에 async/await 키워드를 여기저기 붙여주는 곳은 위험할 수 있다.

![스크린샷 2022-11-22 오후 10 45 07](https://user-images.githubusercontent.com/87598209/203333054-ed68f5ab-ad77-4b92-b917-cfe51615d206.png)

- 이럴 때, 우리는 기존의 메서드를 한번 감싸주는 return 값을 가진 새로운 async 함수를 만들어준다
- withCheckedThrowingContinuation 메서드의 경우, 기존의 메서드가 error를 throw하지 않는다면 withCheckedContinuation을 사용해준다
- 이렇게 사용해줌으로써, 우리는 async 비동기 함수의 장점도 가져갈 수 있고 기존의 비동기 코드를 리팩토링할 필요없이 안전하게 계속해서 사용해줄 수 있다
