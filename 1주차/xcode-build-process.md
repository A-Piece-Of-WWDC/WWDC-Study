## ▫︎ Xcode10의 새로운 빌드 시스템

---

- Xcode10에서는 향상된 성능과 안정성을 가진 Build System이 도입됨
- 이 세션을 통해서 command + B, 빌드 버튼을 누르면 어떤 일이 생기는지 알아보자!

## ▫︎ 빌드 프로세스

---

![스크린샷 2022-11-16 오전 3.02.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ec2e310-68da-45c0-9451-0175f07d24c0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.02.36.png)

![스크린샷 2022-11-16 오전 3.04.31.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6f9f0773-8a14-493e-bc87-48e8c0c5bbe8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.04.31.png)

- 반려동물을 보여주는 PetWall이라는 간단한 앱, 이 앱은 일반적으로 우리가 사용하는 프로젝트와 비슷함
- 프로젝트에는 앱 타겟, 프레임워크, Swift 및 Objc의 다양한 소스파일이 있음
- 따라서 앱을 빌드할 때, 프로젝트의 소스코드 및 리소스에서 배포를 위해 앱스토어에 업로드하는 패키지까지 관련된 여러 단계가 존재함
    1. 소스 코드를 컴파일하고 링크
    2. 헤더, 에셋 카탈로그 및 스토리보드와 같은 리소스를 복사하고 처리
    3. code sign을 하고 프레임워크용 API 문서 작성이나 코드 린팅 및 유효성 검사 도구 실행과 같은 셀 스크립트 또는 makefile에서 일부 사용자 지정 작업 수행함
- 빌드 프로세스에서 이러한 작업의 대부분은 command line tool을 실행하여 수행됨
- Clang, LD, AC 도구, IB도구, 코드 사인 등.. 이런 도구는 Xcode 프로젝트의 구성에 따라 **특정 순서로 매우 특정한 argument의 set**와 함께 실행되어야 함.
- 따라서 빌드 시스템이 수행하는 작업은, 빌드를 할 때마다 이런 작업의 오케스트레이션 및 실행을 자동화하는 것
- 복잡한 상호 종속성을 가진 빌드 프로세스에는 수만개, 혹은 그보다 더 많은 작업이 포함될 수 있는데 우리가 직접 터미널에 하나하나 칠 필요는 없으며 빌드 시스템이 이걸 대신해줌!

- 앞에서 “빌드 프로세스의 작업은 특정 순서로 실행”된다고 하였는데 이런 순서는 어떻게 결정되고, 왜 중요할까?

![스크린샷 2022-11-16 오전 3.24.19.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c931b856-2027-44cc-b651-49e7f2d4a1cd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.24.19.png)

- 빌드 작업이 실행되는 순서는 `작업의 종속성 정보`,  `작업이 소비하는 입력 및 생성되는 출력`에 따라 결정됨

![스크린샷 2022-11-16 오전 3.27.06.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a54b0799-7c47-403e-8e69-6e1d88cdaa1c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.27.06.png)

- 예를 들어 컴파일 작업은 PetViewController.m과 같은 소스 코드 파일을 입력으로 사용함
→ PetController.o와 같은 객체 파일을 출력

![스크린샷 2022-11-16 오전 3.27.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/613e9b98-f681-4432-b5f7-186644a9dd8d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.27.36.png)

- 링커 작업은 이전 작업에서 컴파일러가 생성한 여러 객체 파일을 입력으로 사용함
→ 실행파일 또는 라이브러리를 출력

![스크린샷 2022-11-16 오전 3.32.34.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee0ec7b1-7fe4-4537-bdb1-1377282d3ebf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.32.34.png)

- 이러한 출력과 생성은 같은 패턴이 반복되는 걸 알 수 있음
- 그래프 구조를 통해서, 의존성이 어떻게 흐르는지 알 수 있게 되고 결과적으로 실행되어야 하는 순서를 알려주게 됨
- 빌드 시스템은 이런 종속성 정보를 사용하여 `작업을 실행해야하는 순서`와 `병렬로 실행할 수 있는 작업을 결정`하며, 이것을 **Dependency Order 종속성 순서**라고 함

## ▫︎ 일반적인 앱을 빌드할 때 어떻게 작동할까요?

---

1. 빌드 시스템이 build Description 인 Xcode 프로젝트 파일을 가져옴
2. 구문을 분석하고 프로젝트의 모든 파일, 대상 및 종속성 관계를 고려함
3. build setting을 지정하고, directed graph(유향그래프)라고 하는 트리와 같은 구조로 바꿈
    
    ![이 그래프는 프로젝트의 입력 및 출력 파일과 이를 처리하기 위해 실행될 작업간의 모든 종속성을 나타냄](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5999fc88-090b-4077-990b-b659e9abed24/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.41.44.png)
    
    이 그래프는 프로젝트의 입력 및 출력 파일과 이를 처리하기 위해 실행될 작업간의 모든 종속성을 나타냄
    
4. 하위 수준의 실행 엔진(llbuild)은 이 그래프를 처리하고, 종속성 사양을 살펴보고 실행할 작업을 파악함
5. 실행해야하는 순서, 병렬로 실행할 수 있는 작업 등을 고려하여 실행
    
    ![스크린샷 2022-11-16 오전 3.43.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27a21030-f105-457c-9f33-8023500d97ee/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_3.43.47.png)
    
- 결론적으로 llbuild가 작업간의 모든 종속성을 나타내는 유향 그래프를 보고 실행순서/병렬로 수행 할 수 있는 작업들을 파악하고 실행함

## ▫︎ 발견된 종속성

---

- 빌드 시스템은 실제로 작업을 실행하면서, 실제 그래프에 있는 것보다 더 많은 종속성에 대한 정보를 얻을 수 있음
- 예를 들어 Clang이 Objective-C 파일을 컴파일하면 예상하는대로 오브젝트 파일을 만듦. 하지만 해당 소스 파일에 포함된 헤더 파일 목록이 포함된 다른 파일을 생성할 수도 있음

## ▫︎ 증분 빌드 Incremental Builds

---

- 프로젝트가 클수록 빌드하는데 많은 시간이 걸림, 그런데 빌드를 할 때마다 모든 태스크를 반복한다면 매우 비효율적
- 그래서 빌드 시스템은 그래프의 태스크에서 subset만 실행할 수 있도록 해주는데 이를 증분 빌드라고 함
- 증분 빌드가 정확하고, 효율적으로 작동하기 위해서는 정확한 종속성 정보를 갖는 것이 매우 중요함
- 변경사항이 빌드 시스템에 어떤 영향을 미치고 증분 빌드와는 어떤 관련이 있을까?
    1. 빌드 프로세스의 각 작업에는 해당 작업과 관련된 정보에서 계산되는 일종의 hash인 연관 서명이 있음
    2. 이 정보에는 파일 경로 및 수정 타임스탬프와 같은 작업 입력에 대한 통계 정보가 포함됨
    (사용중인 컴파일러 버전과 같은 기타 작업별 메타데이터 등)
    3. 빌드 시스템은 현재 빌드와 이전 빌드 모두에서 이 작업의 signiture를 추적함
    4. 그래서 빌드가 수행될 때마다 작업을 다시 실행할지 여부를 알 수 있음
    5. 지정된 작업의 시그니처가 이전 빌드의 시그니처랑 다른 경우 빌드 시스템은 해당 작업을 다시 실행함.
    시그니처가 같으면 그냥 건너뜀
- 어차피 빌드 시스템이 해주기 때문에 작업 실행 순서에 대해 딱히 생각하지 않아도 됨. 하지만 개발자로서 작업 간의 종속성에 대해 생각하고, **빌드 시스템이 그래프 구조에 따라 작업을 가장 잘 실행하는 방법을 파악하도록 해야함.**
- 이를 통해서 빌드 시스템은 멀티코어 하드웨어를 최대한 활용하기위해 작업을 올바르게 정렬하고 가능한 경우에는 병렬적으로 작업할 수 있도록 할 수 있음

## ▫︎ 그렇다면 종속성은 어디서 오는 걸까?

---

### 1️⃣ Built in 빌드 시스템 내에서의 빌드 방식

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0fe16e5-0599-4975-9e40-2dfb26158e8e/Untitled.png)

- 특정 작업의 경우 종속성 정보는 빌드 시스템에 내장된 지식에서 가져옴
- 빌드 시스템에는 컴파일러, 링크, 에셋 카탈로그 및 스토리보드 프로세서 등에 대한 규칙이 제공
- 그리고 이런 규칙은 어떤 종류의 파일이 입력으로 허용되고, 어떤 출력이 생성되는지를 정의

### 2️⃣ Target Dependencies 대상 종속성

- 타겟이 빌드되는 순서를 대략적으로 결정함
- 이전 엑스코드에서는 타겟이 빌드될 때 전체 종속 타겟의 컴파일을 완료해야 시작할 수 있었는데, 현재 빌드 시스템은 다른 타겟들과 병렬 소스들을 컴파일 할 수 있음
- 소스 컴파일 단계가 비용 없이 일부 병렬화를 제공하기 위해, 더 일찍 시작할 수 있음
- run script phases를 사용하는 경우, 이 병렬화가 적용되기 전에 해당 스크립트 단계를 완료해야해서 빌드가 더 느려질 수 있음

### 3️⃣ Implict Dependencies 암시적 종속성

- 예를 들어 binary build phase가 있는 링크 라이브러리의 Target을 나열하고
schema editer에서 Implict Dependencies이 활성화된 경우(default), 빌드 시스템은 Target dependencies에 나열되지 않더라도 해당 Target에 대한 Implict Dependencies을 설정한다.

Edit Schema에 암시적 종속성이 활성화 되어있으면 따로  dependencies에 나열되어 있지 않더라도 링크 라이브러리에 표시가 된다는 말

### 4️⃣ Build phase Dependencies 빌드 단계 종속성

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e529d67-0ba5-4f5f-b811-87af5d0d6f13/Untitled.png)

- 각 phase와 관련된 작업은 일반적으로 단계가 나열된 순서에 따라 그룹을 실행
- 그러나 빌드 시스템이 더 잘알고 있는 경우 해당 순서를 무시할 수 있음
→ 빌드 시스템이 임의로 순서를 무시하는 경우도 있나봄
- build phase 순서가 잘못되면, 빌드 이슈 또는 실패가 발생할 수 있으니 종속성을 이해하고, build phase가 올바른 순서인지 확인해야 함

### 5️⃣ Schema order Dependencies 스킴 순서 종속성

- scheme setting에서 parallelize build 체크박스를 활성화(default)하면 더나은 빌드 성능을 얻을 수 있으며, schema target의 순서는 별로 중요하지 않음
- 그런데 비활성화하면 나열된 순서로 Taget을 하나씩 빌드함. 따라서 병렬 처리가 안되기 때문에 빌드 속도가 느려짐.
    
    ![스크린샷 2022-11-16 오전 4.45.45.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c7142344-842f-403b-845d-2738f1759d67/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.45.45.png)
    
- parallelize build를 활성화하고, Target Dependencies를 올바르게 설정하고, 순서에 의존하지 않는 것을 권장
- 그래서 그런지 Xcode14에는 parallelize build 옵션이 아무리 찾아봐도 없음.. 아예 defualt로 설정된 걸까요

![스크린샷 2022-11-16 오전 4.40.57.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8dc142a0-b6b7-41c2-af15-660992e4e71e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.40.57.png)

### 6️⃣ You!

---

마지막으로 종속성은 you🫵 한테서 나온다고 합니다.

![스크린샷 2022-11-16 오전 4.49.48.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a4cf0792-72e9-42ab-8bdd-1c6e424261dd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-16_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_4.49.48.png)

- custom shell script build phases 또는 build rules을 작성하는 경우, 빌드시스템에 input 및 output을 직접 입력할 수 있음
- 이렇게 Input/Output을 알려주면?
    - 빌드 시스템이 불필요하게 스크립트 작업을 재실행하지 않아도 됨
    - 올바른 순서로 실행되게 할 수 있음

## ▫︎ Xcode 빌드 시스템이 Clang 컴파일러를 호출하면 뒤에서 어떤 일이 일어나는지!

---

이때까지 swift만 사용했을지 모르지만, swift 또한 배후에는 clang을 사용함

### What is Clang?

- 클랭은 apple의 공식적인 C컴파일러이자 대부분의 프레임워크에 사용되는 Objective-C와 같은 C언어를 위한 컴파일러임
- iOS에서 API에 액세스하거나, 자신의 코드에서 구현에 액세스하려면 일반적으로 헤더 파일을 포함해야함
- 헤더파일은 해당 구현이 다른 곳에 있다는 약속
- 그런데 아래 예시를 보면 파일, 헤더들의 위치를 변경시켜도 문제없이 빌드가 가능한 걸 알 수 있음
이유는 컴파일러가 헤더맵을 사용해서 헤더파일을 찾기 때문, 헤더맵은 Xcode 빌드 시스템에서 해당 헤더파일이 있는 위치를 통신하는 데 사용

![왼쪽이 변경된 폴더, 오른쪽은 수정하지 않은 헤더 import 부분](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d96918ef-6515-4670-9365-c03569933d7a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-11-17_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_2.56.47.png)

왼쪽이 변경된 폴더, 오른쪽은 수정하지 않은 헤더 import 부분

- 빌드 로그를 복사해서 터미널에 붙여넣기한 후, -v 옵션을 추가하면 clang이 이 빌드에 대한 정보를 알려줌 그러면 헤더맵에 대한 정보를 알 수 있음
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2481b8a-d8bb-44f3-9b55-350767989f44/Untitled.png)
    
- 그렇게 헤더 파일을 호출하고나면 엄청 많은 코드들이 생성됨
같은 헤더를 다른 파일에서 각각 호출하면 코드들이 엄청 방대해짐
- foundation.h는 시스템에서 매우 기본적인 헤더인데, 모든 컴파일러 호출에서 이 헤더를 찾아야할 가능성이 높음. 그렇다면 너무 많은 중복 작업을 하게되는데 → clang 모듈을 사용하면 이를 개선할 수 있음
- 프레임워크당 헤더를 한번만 찾고 구문을 분석한 다음 해당 정보를 디스크에서 저장하여 캐싱하고 재사용할 수 있음. 근데 이럴러면 Clang 모듈에 특정한 속성이 있어야함
1. **Context-free**
아래를 보면 같은 헤더를 임포트함에도 불구하고 다른 매크로 정의를 넣어서 재사용이 불가능함
그래서 모듈이 context와 관련된 모든 정보를 무시하도록 하여 재사용할 수 있도록 해야함

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3e84374-34c8-4908-a434-00b890c610d7/Untitled.png)

1. **Self-contained** 모듈이 독립적
모든 종속성을 나타내야함
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/44a4a88d-443a-4fba-a622-7796ebd91fbf/Untitled.png)
    

## ▫︎ swift compile

---

- 클랭은 각 objective-c 파일을 개별적으로 컴파일 하고, 다른 파일에서 찾기 위해 클래스를 참조하려면 해당 클래스를 선언하는 헤더를 가져와야됨
- swift는 objective-c와 달리 헤더파일을 작성하지않음. 별도의 파일에서 선언을 반복할 필요도 없음.
- 이 덕분에 초보자들이 시작하기 좋음. 하지만 이는 컴파일러가 일부 추가적인 기록 `book-keeping`을 수행해야함을 의미

`PetWall` 앱으로 돌아가 봅시다. 앱에는 ViewController에 Swift로 작성된 view, Objective-C AppDelegate, Swift unit test들이 있음

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f1625b7-caf8-403c-8906-9637e53bb13f/Untitled.png)

PetViewController 파일을 컴파일 하기 위해 컴파일러는 총 네가지 작업을 수행

- Swift 타겟과 Objective-C로부터 오는 두 가지에서 선언문들을 찾아야함
- Objective-C와 다른 Swift 타겟들에서 선언문들을 찾아 사용할 수 있게끔 파일의 내용을 설명하는 인터페이스를 만들어야함
- 클랭과 달리, 하나의 swift 파일을 컴파일할 때, 컴파일러가 타겟의 다른 모든 swift 파일을 구문 분석함(인터페이스와 관련된 부분)
- xcode9에서는 이를 병렬적으로 모두 탐색했다면, xcode10부터는 이러한 오버헤드를 줄임

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d2401fca-05b5-4486-8dc1-819727cb6067/Untitled.png)

- 많은 작업을 공유하는 그룹으로 파일을 결합하여 이런 작업들을 수행하게 함
그리고 그룹 내에서 파싱 결과를 재사용하고 그룹간에서만 반복 작업이 일어나게 됨. 
→ 즉 그룹별 상대적으로 관련성이 없어야 더 빌드 속도가 빨라짐

## ▫︎ 링커

---

- Xcode 빌드 프로세스의 마지막 작업으로, 컴파일러에 의해 만들어진 object file을 하나의 실행 파일로 만들기 위한 작업
- 실행가능한 Mach-O를 빌드하는 마지막 작업
Mach-O는 애플 OS에서 동작하는 컴파일된 프로그램에 대한 파일 포맷
- 모든 컴파일러의 결과물(`.o` 파일)을 합쳐 하나의 파일로 만듦
    - 컴파일러가 생성한 코드를 이동하거나 수정함
- 두 종류의 인풋 파일을 받음
    - 오브젝트 파일 (`.o`)
    - 라이브러리 (`.dylib`, `.tbd`, `.a`)